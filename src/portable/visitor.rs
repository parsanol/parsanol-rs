//! Visitor pattern for AST traversal
//!
//! This module provides a visitor pattern implementation for traversing and
//! transforming AST nodes generated by the parser.
//!
//! # Overview
//!
//! The visitor pattern allows you to:
//! - Traverse the entire AST in a structured way
//! - Process specific node types
//! - Transform nodes during traversal
//! - Collect information from the AST
//!
//! # Example
//!
//! ```
//! use parsanol::portable::{AstArena, AstNode, visitor::{Visitor, DefaultVisitor}};
//!
//! // Custom visitor that counts string nodes
//! struct StringCounter {
//!     count: usize,
//! }
//!
//! impl Visitor for StringCounter {
//!     fn visit_string_ref(&mut self, _pool_index: u32, _arena: &AstArena) {
//!         self.count += 1;
//!     }
//!
//!     fn visit_input_ref(&mut self, _offset: u32, _length: u32, _input: &str) {
//!         self.count += 1;
//!     }
//! }
//! ```

use super::arena::AstArena;
use super::ast::AstNode;

/// Trait for visiting AST nodes
///
/// Implement this trait to traverse or transform AST nodes.
/// Each method has a default implementation that does nothing,
/// so you only need to override the methods you care about.
pub trait Visitor {
    /// Called when visiting a nil node
    fn visit_nil(&mut self) {}

    /// Called when visiting a boolean node
    fn visit_bool(&mut self, _value: bool) {}

    /// Called when visiting an integer node
    fn visit_int(&mut self, _value: i64) {}

    /// Called when visiting a float node
    fn visit_float(&mut self, _value: f64) {}

    /// Called when visiting a string reference node
    fn visit_string_ref(&mut self, _pool_index: u32, _arena: &AstArena) {}

    /// Called when visiting an input reference node
    fn visit_input_ref(&mut self, _offset: u32, _length: u32, _input: &str) {}

    /// Called before visiting an array
    fn visit_array_start(&mut self, _pool_index: u32, _length: u32) {}

    /// Called after visiting an array
    fn visit_array_end(&mut self, _pool_index: u32, _length: u32) {}

    /// Called before visiting a hash
    fn visit_hash_start(&mut self, _pool_index: u32, _length: u32) {}

    /// Called when visiting a hash key
    fn visit_hash_key(&mut self, _key: &str) {}

    /// Called after visiting a hash
    fn visit_hash_end(&mut self, _pool_index: u32, _length: u32) {}

    /// Visit a node and its children
    fn visit_node(&mut self, node: &AstNode, arena: &AstArena, input: &str) {
        match node {
            AstNode::Nil => {
                self.visit_nil();
            }
            AstNode::Bool(value) => {
                self.visit_bool(*value);
            }
            AstNode::Int(value) => {
                self.visit_int(*value);
            }
            AstNode::Float(value) => {
                self.visit_float(*value);
            }
            AstNode::StringRef { pool_index } => {
                self.visit_string_ref(*pool_index, arena);
            }
            AstNode::InputRef { offset, length } => {
                self.visit_input_ref(*offset, *length, input);
            }
            AstNode::Array { pool_index, length } => {
                self.visit_array_start(*pool_index, *length);
                let items = arena.get_array(*pool_index as usize, *length as usize);
                for item in &items {
                    self.visit_node(item, arena, input);
                }
                self.visit_array_end(*pool_index, *length);
            }
            AstNode::Hash { pool_index, length } => {
                self.visit_hash_start(*pool_index, *length);
                let pairs = arena.get_hash_items(*pool_index as usize, *length as usize);
                for (key, value) in pairs {
                    self.visit_hash_key(&key);
                    self.visit_node(&value, arena, input);
                }
                self.visit_hash_end(*pool_index, *length);
            }
        }
    }
}

/// A default visitor that does nothing
///
/// Use this as a base for custom visitors when you only want to
/// override a few methods.
pub struct DefaultVisitor;

impl Visitor for DefaultVisitor {}

/// A visitor that counts nodes of each type
///
/// # Example
///
/// ```
/// use parsanol::portable::visitor::NodeCounter;
/// use parsanol::portable::{AstArena, AstNode, visitor::Visitor};
///
/// let mut arena = AstArena::new();
/// let node = arena.intern_string("hello");
///
/// let mut counter = NodeCounter::new();
/// counter.visit_node(&node, &arena, "");
///
/// assert_eq!(counter.strings, 1);
/// ```
#[derive(Debug, Clone, Default)]
pub struct NodeCounter {
    /// Number of nil nodes
    pub nils: usize,
    /// Number of boolean nodes
    pub bools: usize,
    /// Number of integer nodes
    pub ints: usize,
    /// Number of float nodes
    pub floats: usize,
    /// Number of string nodes (StringRef + InputRef)
    pub strings: usize,
    /// Number of array nodes
    pub arrays: usize,
    /// Number of hash nodes
    pub hashes: usize,
}

impl NodeCounter {
    /// Create a new counter with all counts set to zero
    pub fn new() -> Self {
        Self::default()
    }

    /// Get the total number of nodes visited
    pub fn total(&self) -> usize {
        self.nils + self.bools + self.ints + self.floats + self.strings + self.arrays + self.hashes
    }
}

impl Visitor for NodeCounter {
    fn visit_nil(&mut self) {
        self.nils += 1;
    }

    fn visit_bool(&mut self, _value: bool) {
        self.bools += 1;
    }

    fn visit_int(&mut self, _value: i64) {
        self.ints += 1;
    }

    fn visit_float(&mut self, _value: f64) {
        self.floats += 1;
    }

    fn visit_string_ref(&mut self, _pool_index: u32, _arena: &AstArena) {
        self.strings += 1;
    }

    fn visit_input_ref(&mut self, _offset: u32, _length: u32, _input: &str) {
        self.strings += 1;
    }

    fn visit_array_start(&mut self, _pool_index: u32, _length: u32) {
        self.arrays += 1;
    }

    fn visit_hash_start(&mut self, _pool_index: u32, _length: u32) {
        self.hashes += 1;
    }
}

/// A visitor that collects all strings from the AST
///
/// # Example
///
/// ```
/// use parsanol::portable::visitor::StringCollector;
/// use parsanol::portable::{AstArena, AstNode, visitor::Visitor};
///
/// let mut arena = AstArena::new();
/// let node = arena.intern_string("hello");
///
/// let mut collector = StringCollector::new();
/// collector.visit_node(&node, &arena, "");
///
/// assert_eq!(collector.strings, vec!["hello"]);
/// ```
#[derive(Debug, Clone, Default)]
pub struct StringCollector {
    /// Collected strings
    pub strings: Vec<String>,
}

impl StringCollector {
    /// Create a new string collector
    pub fn new() -> Self {
        Self::default()
    }
}

impl Visitor for StringCollector {
    fn visit_string_ref(&mut self, pool_index: u32, arena: &AstArena) {
        self.strings
            .push(arena.get_string(pool_index as usize).to_string());
    }

    fn visit_input_ref(&mut self, offset: u32, length: u32, input: &str) {
        let start = offset as usize;
        let end = start + (length as usize);
        if end <= input.len() {
            self.strings.push(input[start..end].to_string());
        }
    }
}

/// A visitor that finds the maximum nesting depth
///
/// # Example
///
/// ```
/// use parsanol::portable::visitor::DepthAnalyzer;
/// use parsanol::portable::{AstArena, AstNode, visitor::Visitor};
///
/// let mut arena = AstArena::new();
/// let node = AstNode::Int(42);
///
/// let mut analyzer = DepthAnalyzer::new();
/// analyzer.visit_node(&node, &arena, "");
///
/// assert_eq!(analyzer.max_depth, 0);
/// ```
#[derive(Debug, Clone)]
pub struct DepthAnalyzer {
    /// Current depth during traversal
    pub current_depth: usize,
    /// Maximum depth encountered
    pub max_depth: usize,
}

impl DepthAnalyzer {
    /// Create a new depth analyzer
    pub fn new() -> Self {
        Self {
            current_depth: 0,
            max_depth: 0,
        }
    }
}

impl Default for DepthAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

impl Visitor for DepthAnalyzer {
    fn visit_array_start(&mut self, _pool_index: u32, _length: u32) {
        self.current_depth += 1;
        self.max_depth = self.max_depth.max(self.current_depth);
    }

    fn visit_array_end(&mut self, _pool_index: u32, _length: u32) {
        self.current_depth = self.current_depth.saturating_sub(1);
    }

    fn visit_hash_start(&mut self, _pool_index: u32, _length: u32) {
        self.current_depth += 1;
        self.max_depth = self.max_depth.max(self.current_depth);
    }

    fn visit_hash_end(&mut self, _pool_index: u32, _length: u32) {
        self.current_depth = self.current_depth.saturating_sub(1);
    }
}

/// Walk an AST with a visitor
///
/// This is a convenience function for visiting an AST.
///
/// # Example
///
/// ```
/// use parsanol::portable::visitor::{walk, NodeCounter};
/// use parsanol::portable::{AstArena, AstNode};
///
/// let mut arena = AstArena::new();
/// let node = arena.intern_string("hello");
///
/// let counter = NodeCounter::new();
/// let result = walk(&node, &arena, "", counter);
///
/// assert_eq!(result.strings, 1);
/// ```
pub fn walk<V: Visitor>(node: &AstNode, arena: &AstArena, input: &str, mut visitor: V) -> V {
    visitor.visit_node(node, arena, input);
    visitor
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_visitor() {
        let mut arena = AstArena::new();
        let node = arena.intern_string("hello");

        let mut visitor = DefaultVisitor;
        visitor.visit_node(&node, &arena, "hello");
        // Should not panic
    }

    #[test]
    fn test_node_counter() {
        let mut arena = AstArena::new();

        // Create various nodes
        let nil_node = AstNode::Nil;
        let bool_node = AstNode::Bool(true);
        let int_node = AstNode::Int(42);
        let float_node = AstNode::Float(3.14);
        let string_node = arena.intern_string("hello");

        // Create an array
        let items = vec![int_node, float_node];
        let (pool_index, length) = arena.store_array(&items);
        let array_node = AstNode::Array { pool_index, length };

        let mut counter = NodeCounter::new();
        counter.visit_node(&nil_node, &arena, "");
        assert_eq!(counter.nils, 1);

        counter = NodeCounter::new();
        counter.visit_node(&bool_node, &arena, "");
        assert_eq!(counter.bools, 1);

        counter = NodeCounter::new();
        counter.visit_node(&string_node, &arena, "hello");
        assert_eq!(counter.strings, 1);

        counter = NodeCounter::new();
        counter.visit_node(&array_node, &arena, "");
        assert_eq!(counter.arrays, 1);
        assert_eq!(counter.ints, 1);
        assert_eq!(counter.floats, 1);
        assert_eq!(counter.total(), 3);
    }

    #[test]
    fn test_string_collector() {
        let mut arena = AstArena::new();

        let string_node = arena.intern_string("hello");
        let input_node = arena.input_ref(0, 5);

        let mut collector = StringCollector::new();
        collector.visit_node(&string_node, &arena, "");
        assert_eq!(collector.strings, vec!["hello"]);

        collector = StringCollector::new();
        collector.visit_node(&input_node, &arena, "world");
        assert_eq!(collector.strings, vec!["world"]);
    }

    #[test]
    fn test_depth_analyzer() {
        let mut arena = AstArena::new();

        // Single node: depth 0
        let int_node = AstNode::Int(42);
        let mut analyzer = DepthAnalyzer::new();
        analyzer.visit_node(&int_node, &arena, "");
        assert_eq!(analyzer.max_depth, 0);

        // Nested array: depth 2
        let inner_items = vec![AstNode::Int(1), AstNode::Int(2)];
        let (inner_pool, inner_len) = arena.store_array(&inner_items);
        let inner_array = AstNode::Array {
            pool_index: inner_pool,
            length: inner_len,
        };

        let outer_items = vec![inner_array];
        let (outer_pool, outer_len) = arena.store_array(&outer_items);
        let outer_array = AstNode::Array {
            pool_index: outer_pool,
            length: outer_len,
        };

        analyzer = DepthAnalyzer::new();
        analyzer.visit_node(&outer_array, &arena, "");
        assert_eq!(analyzer.max_depth, 2);
    }

    #[test]
    fn test_walk_function() {
        let mut arena = AstArena::new();
        let node = arena.intern_string("test");

        let counter = walk(&node, &arena, "test", NodeCounter::new());
        assert_eq!(counter.strings, 1);
    }
}
